# Shire — Project Proposal

## Overview

Shire is a native-feeling desktop application that turns any folder on your machine into an AI-powered workspace. You point it at a directory, and it gives you a chat interface where an LLM can search, read, and write files within that directory — acting as a local coding assistant grounded in your actual project files.

---

## Core Concepts

### Workspace
A workspace is a reference to a local directory. It stores metadata (name, path, created date) and serves as the root scope for all AI operations. The AI cannot access files outside the workspace directory.

### Chat Session
Each workspace can have multiple independent chat sessions. A session is a linear conversation thread between the user and the model. Sessions are persisted in full — messages, tool calls, tool results, and generated artifacts.

### Artifact
When the AI writes or creates a file, two things happen:
1. The actual file is saved to disk inside the workspace directory.
2. A database record (artifact) is created linking the chat session to that file path, capturing metadata like creation time and the generating message.

---

## Features

### v0.1 — MVP

- **Workspace management** — Create, open, rename, delete workspaces (each backed by a local folder).
- **Sidebar navigation** — Persistent sidebar listing workspaces with nested chat sessions (5 most recent shown per workspace, "Show more" expands the rest).
- **Chat interface** — Multi-turn conversation with an LLM within a workspace. Streaming responses rendered with Streamdown.
- **File system tools** — The model can:
  - **Search files** — glob-based file discovery (via fast-glob).
  - **Search content** — ripgrep-powered full-text search across the workspace.
  - **Read files** — Read file contents (full or partial, with line ranges).
  - **Write files** — Create or overwrite files in the workspace directory.
  - **List directory** — Enumerate directory contents.
- **Session persistence** — All messages, tool calls, and results stored in SQLite.
- **Artifact tracking** — Files generated by the AI are tracked as artifacts linked to the originating session and message.
- **Tool call display** — Collapsible blocks showing tool name, summary, and expandable input/output.
- **Auto-generated session titles** — Model generates a short title after the first exchange.
- **Multi-provider support** — Anthropic, OpenAI, and OpenAI-compatible endpoints (Ollama, LMStudio) via AI SDK provider registry.
- **Token usage tracking** — Per-message token counts stored in DB, running total shown per session.
- **Model configuration** — Settings page for API keys, provider, and model selection.

### Future (out of scope for v0.1)

- File diff view for AI-generated changes.
- Git integration (commit, diff, branch awareness).
- Workspace-level context/system prompt customization.
- File edit tool (patch-based partial edits instead of full rewrites).
- RAG over workspace files (embeddings + vector search).
- Plugin/extension system for custom tools.
- Multi-window support (one window per workspace).
- Auto-updates via `electron-updater`.
- Conversation summarization for long context management.

---

## Architecture

```
shire/
├── apps/
│   └── desktop/                    # Electron app (electron-vite)
│       ├── src/
│       │   ├── main/               # Electron main process
│       │   │   ├── index.ts                  # App entry, window management, native feel
│       │   │   ├── ipc.ts                    # IPC handler registration
│       │   │   ├── workspace.ts              # Workspace CRUD operations
│       │   │   └── chat.ts                   # Chat orchestration (AI SDK + streaming)
│       │   ├── preload/            # Preload scripts (context bridge)
│       │   │   └── index.ts
│       │   └── renderer/           # React frontend
│       │       ├── app.tsx                   # Root layout — sidebar + main content
│       │       ├── routes.tsx                # React Router (MemoryRouter) config
│       │       ├── pages/
│       │       │   ├── home.tsx              # Welcome / empty state
│       │       │   ├── workspace.tsx         # Workspace overview
│       │       │   └── chat.tsx              # Chat view for a session
│       │       ├── components/
│       │       │   ├── sidebar/
│       │       │   │   ├── sidebar.tsx             # Main sidebar container
│       │       │   │   ├── workspace-item.tsx      # Workspace row (expandable)
│       │       │   │   ├── session-item.tsx         # Chat session row
│       │       │   │   └── sidebar-footer.tsx       # Settings + new workspace
│       │       │   ├── chat/
│       │       │   │   ├── message-list.tsx         # Scrollable message feed
│       │       │   │   ├── message.tsx              # Single message (Streamdown rendering)
│       │       │   │   ├── input.tsx                # Composer textarea
│       │       │   │   ├── tool-call-block.tsx      # Collapsible tool call display
│       │       │   │   └── artifact-badge.tsx       # Inline artifact indicator
│       │       │   ├── workspace/
│       │       │   │   └── artifact-list.tsx        # Session artifact listing
│       │       │   └── ui/                   # shadcn/ui primitives
│       │       ├── stores/
│       │       │   ├── workspace.ts           # Zustand workspace store
│       │       │   ├── chat.ts                # Zustand chat/streaming store
│       │       │   └── settings.ts            # Zustand settings store
│       │       └── lib/
│       │           ├── ipc.ts                 # Typed IPC client helpers
│       │           └── markdown.ts            # Streamdown config + plugins
│       ├── electron.vite.config.ts
│       ├── electron-builder.config.ts
│       └── package.json
│
├── packages/
│   ├── db/                         # Database layer
│   │   ├── src/
│   │   │   ├── index.ts            # DB connection + Drizzle client export
│   │   │   ├── schema.ts           # All table definitions
│   │   │   └── migrations/         # Drizzle Kit generated migrations
│   │   ├── drizzle.config.ts
│   │   └── package.json
│   │
│   └── tools/                      # AI SDK-compatible tool definitions
│       ├── src/
│       │   ├── index.ts            # Tool registry — createTools(workspaceRoot)
│       │   ├── glob.ts             # File search by pattern
│       │   ├── ripgrep.ts          # Content search via ripgrep
│       │   ├── read-file.ts        # Read file contents
│       │   ├── write-file.ts       # Write/create files
│       │   ├── list-dir.ts         # Directory listing
│       │   └── utils/
│       │       ├── sandbox.ts      # Path resolution + traversal prevention
│       │       └── binary.ts       # Binary file detection
│       └── package.json
│
├── turbo.json
├── package.json                    # Root workspace config (pnpm)
└── PROPOSAL.md
```

---

## Decisions

All technical decisions, finalized.

| # | Decision | Choice | Notes |
|---|---|---|---|
| 1 | Electron build tooling | **electron-vite** | HMR for main/preload/renderer, Vite-native |
| 2 | Frontend navigation | **React Router (MemoryRouter)** | Sidebar drives navigation, routes for `/`, `/workspace/:id`, `/workspace/:id/chat/:sessionId` |
| 3 | State management | **Zustand** | Minimal boilerplate, good streaming perf, separate stores per domain |
| 4 | Chat streaming (IPC) | **Chunked IPC events** | `webContents.send('chat:delta', chunk)`, renderer listens with `ipcRenderer.on` |
| 5 | Model providers | **Multi-provider (Anthropic, OpenAI, OpenAI-compatible)** | AI SDK provider registry, user picks in settings |
| 6 | API key storage | **Electron `safeStorage`** | OS keychain encryption (Keychain / DPAPI / libsecret) |
| 7 | Database location | **`app.getPath('userData')`** | Single global SQLite file: `~/.config/Shire/shire.db` (or platform equivalent) |
| 8 | Migrations | **Drizzle Kit `migrate()` on app startup** | Auto-runs pending migrations at launch |
| 9 | Session titles | **Auto-generated after first exchange** | Model produces 4-6 word title, "New Chat" placeholder until then |
| 10 | Tool call display | **Collapsible blocks** | Summary line + expandable full I/O |
| 11 | Write file behavior | **Auto-write, artifact tracked, revert available** | No confirmation dialog in v0.1, writes go straight to disk |
| 12 | File size limits | **512KB read / 256KB write, binary detection** | Return error to model for oversized or binary files |
| 13 | Markdown rendering | **Streamdown** | Vercel's streaming-aware markdown parser with plugin support |
| 14 | UI components | **shadcn/ui** | Tailwind-native, copy-paste, full styling control |
| 15 | Token tracking | **Stored per-message, displayed per-session** | `usage` from AI SDK response, running total in session header |
| 16 | Window management | **Single window** | One workspace active at a time, sidebar for switching |
| 17 | Context overflow | **Naive truncation (last N messages within budget)** | v0.2 will add summarization |
| 18 | AI call errors | **Retry with backoff (max 2) + error message in chat** | Transient failures retried, persistent ones surfaced to user |
| 19 | Auto-updates | **Deferred to post-v0.1** | Manual GitHub releases initially |

---

## Tech Stack

| Layer | Technology | Rationale |
|---|---|---|
| Monorepo | **Turborepo + pnpm** | Fast builds, dependency caching, strict workspaces |
| Desktop shell | **Electron + electron-vite** | Cross-platform desktop, Vite-based DX with HMR |
| Packaging | **electron-builder** | Mature, handles platform-specific bundling (including ripgrep binary) |
| Frontend | **React 19 + Tailwind CSS v4** | Standard stack |
| UI components | **shadcn/ui** | Tailwind-native primitives |
| Routing | **React Router v7 (MemoryRouter)** | In-memory routing for Electron renderer |
| State | **Zustand** | Lightweight, streaming-friendly |
| Markdown | **Streamdown** | Streaming markdown rendering with plugin support |
| AI orchestration | **Vercel AI SDK (`ai`)** | Unified tool-calling + streaming across providers |
| Database | **SQLite via `better-sqlite3`** | Local-first, embedded, zero-config |
| ORM | **Drizzle ORM + Drizzle Kit** | Type-safe, lightweight, migration tooling |
| File search | **`fast-glob`** | Fast glob pattern matching |
| Content search | **`@vscode/ripgrep`** | Bundled ripgrep binary, fast regex search |
| Package manager | **pnpm** | Strict, fast, workspace-native |

---

## Native Desktop Feel

Key decisions to make Shire feel like a proper native app, not a wrapped website:

### Window Chrome
- **Frameless window with custom title bar** — Use `titleBarStyle: 'hiddenInset'` on macOS for native traffic lights with a custom drag region. On Windows/Linux, use a custom title bar with window controls.
- **Vibrancy / background material** — Use `vibrancy: 'sidebar'` (macOS) for the sidebar panel to match native translucency. Fall back to a solid muted background on other platforms.
- **Proper window state persistence** — Remember window position, size, and maximized state across restarts. Store in `electron-store` or the DB.

### Interactions
- **Native context menus** — Right-click on workspaces, sessions, and messages triggers Electron `Menu` (not a DOM dropdown).
- **Keyboard-first** — `Cmd+N` new session, `Cmd+Shift+N` new workspace, `Cmd+[1-9]` switch sessions, `Cmd+K` command palette (v0.2). Standard `Cmd+,` for settings.
- **Drag and drop** — Drop a folder onto the window to create a workspace.
- **System tray** — Optional tray icon for quick workspace access (defer to v0.2).

### Typography & Spacing
- **System font stack** — `-apple-system, BlinkMacSystemFont, 'Segoe UI', ...` for UI. Monospace font (`'SF Mono', 'Cascadia Code', 'JetBrains Mono', monospace`) for code blocks and tool output.
- **macOS-style spacing** — Generous padding, proper 8px grid alignment, subtle borders (not harsh lines).

### Sidebar
- **Fixed width, resizable** — Default 260px, user can drag to resize, min 200px / max 400px.
- **Workspace sections** — Each workspace is a collapsible group. Clicking the workspace name navigates to the workspace view. The chevron expands to show sessions.
- **Session list** — Shows 5 most recent sessions under each workspace. A "Show more..." row at the bottom loads all sessions in a scrollable sub-list.
- **Active state** — Current session highlighted with a subtle accent background. Workspace of the active session is auto-expanded.
- **Footer** — New workspace button + settings gear icon, pinned to the bottom.

### Animations
- **Minimal, purposeful** — Sidebar expand/collapse uses `150ms ease-out`. Page transitions use a subtle `100ms` fade. No gratuitous motion.
- **Streaming cursor** — Blinking block cursor at the end of streaming text, removed on completion.

---

## Database Schema

```sql
-- All IDs are UUIDv7 (sortable by creation time)
-- Timestamps are unix milliseconds

CREATE TABLE workspaces (
  id          TEXT PRIMARY KEY,
  name        TEXT NOT NULL,
  path        TEXT NOT NULL UNIQUE,
  created_at  INTEGER NOT NULL,
  updated_at  INTEGER NOT NULL
);

CREATE TABLE sessions (
  id            TEXT PRIMARY KEY,
  workspace_id  TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  title         TEXT,                          -- null until auto-generated
  created_at    INTEGER NOT NULL,
  updated_at    INTEGER NOT NULL
);
CREATE INDEX idx_sessions_workspace ON sessions(workspace_id, updated_at DESC);

CREATE TABLE messages (
  id            TEXT PRIMARY KEY,
  session_id    TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  role          TEXT NOT NULL,                 -- 'user' | 'assistant' | 'tool'
  content       TEXT,                          -- nullable for pure tool-call messages
  tool_calls    TEXT,                          -- JSON: [{ id, name, arguments }]
  tool_call_id  TEXT,                          -- for role='tool', references which call
  token_count   INTEGER,                       -- token usage (input+output for assistant msgs)
  created_at    INTEGER NOT NULL,
  "order"       INTEGER NOT NULL              -- sequence within session
);
CREATE INDEX idx_messages_session ON messages(session_id, "order");

CREATE TABLE artifacts (
  id          TEXT PRIMARY KEY,
  session_id  TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  message_id  TEXT NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
  file_path   TEXT NOT NULL,                  -- relative to workspace root
  operation   TEXT NOT NULL,                  -- 'create' | 'overwrite'
  created_at  INTEGER NOT NULL
);
CREATE INDEX idx_artifacts_session ON artifacts(session_id);

CREATE TABLE settings (
  key   TEXT PRIMARY KEY,
  value TEXT NOT NULL                         -- JSON-encoded value
);
```

---

## Tool Definitions (AI SDK format)

Each tool in `packages/tools` exports a factory function scoped to a workspace root. The package exports a single `createTools(workspaceRoot)` that returns all tools as a record.

```ts
// packages/tools/src/index.ts
import { createGlobTool } from "./glob";
import { createRipgrepTool } from "./ripgrep";
import { createReadFileTool } from "./read-file";
import { createWriteFileTool } from "./write-file";
import { createListDirTool } from "./list-dir";

export function createTools(workspaceRoot: string) {
  return {
    glob: createGlobTool(workspaceRoot),
    ripgrep: createRipgrepTool(workspaceRoot),
    read_file: createReadFileTool(workspaceRoot),
    write_file: createWriteFileTool(workspaceRoot),
    list_dir: createListDirTool(workspaceRoot),
  };
}
```

```ts
// packages/tools/src/read-file.ts — example
import { tool } from "ai";
import { z } from "zod";
import { readFile } from "fs/promises";
import { resolveSandboxed } from "./utils/sandbox";
import { isBinary } from "./utils/binary";

export function createReadFileTool(workspaceRoot: string) {
  return tool({
    description: "Read the contents of a file within the workspace.",
    parameters: z.object({
      path: z.string().describe("Relative path from workspace root"),
      startLine: z.number().optional().describe("1-indexed start line"),
      endLine: z.number().optional().describe("1-indexed end line (inclusive)"),
    }),
    execute: async ({ path, startLine, endLine }) => {
      const resolved = resolveSandboxed(workspaceRoot, path);
      if (isBinary(resolved)) {
        return { error: "Cannot read binary file" };
      }
      const content = await readFile(resolved, "utf-8");
      // handle line range slicing, 512KB cap
      return { content: sliced, lines: totalLines };
    },
  });
}
```

**Tool inventory:**

| Tool | Parameters | Returns | Description |
|---|---|---|---|
| `glob` | `pattern: string`, `path?: string` | `{ files: string[] }` | Find files matching a glob pattern |
| `ripgrep` | `pattern: string`, `glob?: string`, `maxResults?: number` | `{ matches: { file, line, content }[] }` | Regex search across workspace file contents |
| `read_file` | `path: string`, `startLine?: number`, `endLine?: number` | `{ content: string, lines: number }` | Read file (full or line range, max 512KB) |
| `write_file` | `path: string`, `content: string` | `{ written: true, path: string }` | Create or overwrite a file (max 256KB) |
| `list_dir` | `path?: string` | `{ entries: { name, type, size }[] }` | List directory entries with metadata |

All tools validate paths via `resolveSandboxed()` — resolves against workspace root, rejects traversal.

---

## IPC Boundary

Main process owns the database and AI SDK. Renderer communicates via typed IPC:

```ts
// Typed channel definitions (shared types)
type IpcChannels = {
  // Workspace
  "workspace:list":    () => Workspace[];
  "workspace:create":  (args: { name: string; path: string }) => Workspace;
  "workspace:update":  (args: { id: string; name: string }) => Workspace;
  "workspace:delete":  (args: { id: string }) => void;

  // Session
  "session:list":      (args: { workspaceId: string }) => Session[];
  "session:create":    (args: { workspaceId: string }) => Session;
  "session:rename":    (args: { id: string; title: string }) => void;
  "session:delete":    (args: { id: string }) => void;

  // Chat
  "chat:send":         (args: { sessionId: string; content: string }) => void; // triggers stream
  "chat:stop":         (args: { sessionId: string }) => void;                  // abort stream
  "chat:history":      (args: { sessionId: string }) => Message[];

  // Streaming events (main → renderer)
  "chat:delta":        { sessionId: string; delta: string };
  "chat:tool-call":    { sessionId: string; toolCall: ToolCallInfo };
  "chat:tool-result":  { sessionId: string; toolCallId: string; result: unknown };
  "chat:done":         { sessionId: string; message: Message };
  "chat:error":        { sessionId: string; error: string };

  // Artifacts
  "artifact:list":     (args: { sessionId: string }) => Artifact[];

  // Settings
  "settings:get":      () => Settings;
  "settings:set":      (args: Partial<Settings>) => void;

  // System
  "dialog:open-folder": () => string | null;  // native folder picker
};
```

---

## Data Flow — Chat Send

```
User types message in composer
       │
       ▼
Renderer: dispatch to Zustand chat store → call ipc("chat:send", { sessionId, content })
       │
       ▼
Main process (chat.ts):
  1. Load session + workspace from DB
  2. Load message history for session
  3. Build AI SDK messages array (truncate to fit context budget)
  4. Instantiate tools: createTools(workspace.path)
  5. Call streamText({
       model: providerFromSettings(),
       messages,
       tools,
       maxSteps: 10,      // allow multi-step tool use
       onChunk: (chunk) → webContents.send("chat:delta", { sessionId, delta }),
       onToolCall: (tc) → webContents.send("chat:tool-call", { sessionId, toolCall }),
       onToolResult: (tr) → webContents.send("chat:tool-result", { sessionId, ... }),
     })
  6. On finish:
       - Persist user message → messages table
       - Persist assistant message (content + tool_calls JSON) → messages table
       - Persist each tool result → messages table (role='tool')
       - For write_file tool calls → insert into artifacts table
       - Auto-generate session title if this is the first exchange
       - webContents.send("chat:done", { sessionId, message })
       │
       ▼
Renderer: Zustand store receives events → updates message list → React re-renders
  - "chat:delta"       → append to current assistant message (Streamdown renders incrementally)
  - "chat:tool-call"   → append collapsible tool block
  - "chat:tool-result" → update tool block with result
  - "chat:done"        → finalize message, update session title in sidebar if changed
  - "chat:error"       → show error inline, enable retry
```

---

## Security Constraints

- **Path sandboxing** — `resolveSandboxed(root, path)` in `packages/tools` uses `path.resolve(root, path)` then verifies the result starts with `root + path.sep`. Rejects any traversal attempt.
- **No shell execution** — The AI has no shell/exec tool. `@vscode/ripgrep` is spawned as a child process with an argument array (not a shell string).
- **API keys** — Encrypted via `safeStorage.encryptString()`, stored in the settings table as encrypted blobs. Decrypted only in main process memory when making API calls.
- **File size caps** — 512KB read / 256KB write. Binary files detected via file-type magic bytes and rejected.
- **IPC validation** — All IPC handlers validate arguments with Zod before processing.

---

## Build & Development

```bash
# Install dependencies
pnpm install

# Dev — Electron app with HMR (electron-vite)
pnpm dev

# Build all packages
pnpm build

# Build desktop app for distribution
pnpm --filter @shire/desktop build

# Generate DB migration
pnpm --filter @shire/db generate

# Run pending migrations (also runs automatically on app start)
pnpm --filter @shire/db migrate
```

Turborepo pipeline:

```jsonc
// turbo.json
{
  "$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "generate": {},
    "migrate": {}
  }
}
```

---

## Package Dependencies

```
@shire/desktop
  ├── electron
  ├── electron-vite
  ├── electron-builder
  ├── react, react-dom
  ├── react-router
  ├── zustand
  ├── tailwindcss
  ├── streamdown                 (markdown rendering)
  ├── ai                         (AI SDK)
  ├── @ai-sdk/anthropic
  ├── @ai-sdk/openai
  ├── @shire/db
  ├── @shire/tools
  └── shadcn/ui components (copy-pasted, not a dep)

@shire/db
  ├── drizzle-orm
  ├── drizzle-kit
  ├── better-sqlite3
  └── uuid (v7)

@shire/tools
  ├── ai                         (tool() type)
  ├── zod
  ├── fast-glob
  ├── @vscode/ripgrep
  └── file-type                  (binary detection)
```

---

## Sidebar — Detailed Behavior

```
┌──────────────────────────┐
│  Shire                   │  ← app name / logo, drag region
├──────────────────────────┤
│                          │
│  ▼ my-project            │  ← workspace (expanded, bold if active)
│     Session title 1    * │  ← active session (highlighted)
│     Session title 2      │
│     Session title 3      │
│     Session title 4      │
│     Session title 5      │
│     Show more...         │  ← loads remaining sessions inline
│                          │
│  ► another-project       │  ← workspace (collapsed)
│                          │
│  ► old-project           │
│                          │
├──────────────────────────┤
│  [+ New workspace]  [⚙]  │  ← footer actions
└──────────────────────────┘
```

- Clicking a **workspace name** expands/collapses its session list and navigates to the workspace view.
- Clicking a **session** navigates to that chat. Sidebar highlights it.
- **Right-click workspace** → rename, reveal in Finder, delete.
- **Right-click session** → rename, delete.
- **New session** — `+` icon appears on workspace row hover. Creates a session and navigates to it.
- **New workspace** — Opens native folder picker, creates workspace with folder name as default title.
- **Drag to resize** — Right edge of sidebar is draggable. Width persisted in settings.

---

## Implementation Order

Suggested build sequence for v0.1:

1. **Scaffold monorepo** — Turborepo + pnpm workspaces, `apps/desktop`, `packages/db`, `packages/tools`.
2. **`packages/db`** — Drizzle schema, migration generation, DB client with auto-migrate on connect.
3. **`packages/tools`** — All 5 tools with sandbox util. Unit tests against a temp directory.
4. **Electron shell** — electron-vite setup, frameless window, basic React renderer with Tailwind + shadcn.
5. **Sidebar + routing** — Sidebar component, React Router, workspace CRUD (IPC + DB wired up).
6. **Chat core** — Message persistence, `streamText()` integration, chunked IPC streaming, Zustand chat store.
7. **Chat UI** — Message list, Streamdown rendering, tool call blocks, composer input.
8. **Artifacts** — Track write_file calls, show artifact badges in chat, artifact list view.
9. **Settings** — Provider/model selection, API key management with `safeStorage`.
10. **Polish** — Native context menus, keyboard shortcuts, window state persistence, session title auto-gen, error handling + retry.
