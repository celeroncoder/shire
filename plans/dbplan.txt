# Plan: Build DB Service Layer for `packages/db`

## Goal

Create a service layer in `packages/db` that wraps all Drizzle queries into clean, typed functions. The Electron main process will call `service.workspace.list()` instead of writing raw Drizzle queries.

---

## Files to Create/Modify

| File | Action |
|---|---|
| `packages/db/src/types.ts` | **Create** — All TypeScript types derived from schema |
| `packages/db/src/service.ts` | **Create** — `createService(db)` factory with all CRUD operations |
| `packages/db/src/index.ts` | **Modify** — Re-export `createService`, `ShireService`, and all types |
| `packages/db/package.json` | **Modify** — Add `"./types"` export path for renderer-safe type imports |
| `apps/desktop/src/main/index.ts` | **Modify** — Wire up `createService(db)` and export the service |

---

## 1. `packages/db/src/types.ts`

Derive all types from the Drizzle schema using `InferSelectModel` / `InferInsertModel`:

**Select types** (row shapes returned from queries):
- `Workspace`, `Session`, `Message`, `Artifact`, `Setting`

**Insert types** (full Drizzle insert shape, for edge cases):
- `NewWorkspace`, `NewSession`, `NewMessage`, `NewArtifact`, `NewSetting`

**Operation input types** (narrow types consumers pass to service functions):

| Type | Fields | Used by |
|---|---|---|
| `CreateWorkspaceInput` | `{ name, path }` | `workspace.create()` |
| `UpdateWorkspaceInput` | `{ id, name }` | `workspace.update()` |
| `CreateSessionInput` | `{ workspaceId, title? }` | `session.create()` |
| `RenameSessionInput` | `{ id, title }` | `session.rename()` |
| `CreateMessageInput` | `{ sessionId, role, order, content?, toolCalls?, toolCallId?, tokenCount? }` | `message.create()` / `createMany()` |
| `CreateArtifactInput` | `{ sessionId, messageId, filePath, operation }` | `artifact.create()` |
| `SettingsMap` | `Record<string, string \| null>` | `settings.setMany()` / `getAll()` |

---

## 2. `packages/db/src/service.ts`

Single factory function that returns a plain object with 5 domain groups:

```ts
export function createService(db: ShireDatabase) {
  return {
    workspace: { ... },
    session:   { ... },
    message:   { ... },
    artifact:  { ... },
    settings:  { ... },
  };
}
export type ShireService = ReturnType<typeof createService>;
```

> To avoid circular imports, `service.ts` will re-derive the `ShireDatabase` type locally:
> `type ShireDatabase = BetterSQLite3Database<typeof schema>`

All methods are **synchronous** (better-sqlite3 is sync). This is correct for Electron main process — `ipcMain.handle()` accepts both sync and async returns.

### workspace

| Method | Signature | Notes |
|---|---|---|
| `list()` | `() => Workspace[]` | Ordered by `updatedAt DESC` |
| `getById(id)` | `(id: string) => Workspace \| undefined` | |
| `create(input)` | `(input: CreateWorkspaceInput) => Workspace` | Uses `.returning().get()` |
| `update(input)` | `(input: UpdateWorkspaceInput) => Workspace` | Sets `updatedAt: Date.now()` |
| `delete(id)` | `(id: string) => void` | Cascades to sessions/messages/artifacts |

### session

| Method | Signature | Notes |
|---|---|---|
| `listByWorkspace(workspaceId)` | `(workspaceId: string) => Session[]` | Ordered by `updatedAt DESC` |
| `getById(id)` | `(id: string) => Session \| undefined` | |
| `create(input)` | `(input: CreateSessionInput) => Session` | Title defaults to `null` |
| `rename(input)` | `(input: RenameSessionInput) => Session` | Touches `updatedAt` |
| `touch(id)` | `(id: string) => void` | Updates `updatedAt` (call after new messages) |
| `delete(id)` | `(id: string) => void` | Cascades to messages/artifacts |

### message

| Method | Signature | Notes |
|---|---|---|
| `listBySession(sessionId)` | `(sessionId: string) => Message[]` | Ordered by `order ASC` |
| `create(input)` | `(input: CreateMessageInput) => Message` | Single message insert |
| `createMany(inputs)` | `(inputs: CreateMessageInput[]) => Message[]` | Atomic transaction — persist user + assistant + tool messages together |
| `getNextOrder(sessionId)` | `(sessionId: string) => number` | `MAX(order) + 1`, returns `0` for empty sessions |
| `getTokenTotal(sessionId)` | `(sessionId: string) => number` | `SUM(tokenCount)` for session header display |

### artifact

| Method | Signature | Notes |
|---|---|---|
| `listBySession(sessionId)` | `(sessionId: string) => Artifact[]` | Ordered by `createdAt ASC` |
| `create(input)` | `(input: CreateArtifactInput) => Artifact` | Called for each `write_file` tool call |

### settings

| Method | Signature | Notes |
|---|---|---|
| `getAll()` | `() => SettingsMap` | Returns flat `Record<string, string \| null>` |
| `get(key)` | `(key: string) => string \| null` | Returns `null` if key doesn't exist |
| `set(key, value)` | `(key: string, value: string \| null) => void` | Upsert via `onConflictDoUpdate` |
| `setMany(map)` | `(map: SettingsMap) => void` | Upserts all keys in a transaction |

---

## 3. Modify `packages/db/src/index.ts`

Add three lines at the bottom:

```ts
export { createService } from "./service.js";
export type { ShireService } from "./service.js";
export * from "./types.js";
```

---

## 4. Modify `packages/db/package.json`

Add `"./types"` export for renderer-safe imports (no `better-sqlite3` runtime dependency):

```json
"exports": {
  ".": "./dist/index.js",
  "./schema": "./dist/schema.js",
  "./types": "./dist/types.js"
}
```

---

## 5. Modify `apps/desktop/src/main/index.ts`

```ts
import { createDatabase, createService } from "@shire/db";

const db = createDatabase(dbPath, migrationsFolder);
const service = createService(db);

export { db, service };
```

---

## Implementation Order

1. Create `packages/db/src/types.ts`
2. Create `packages/db/src/service.ts`
3. Modify `packages/db/src/index.ts` (add re-exports)
4. Modify `packages/db/package.json` (add `./types` export)
5. Modify `apps/desktop/src/main/index.ts` (wire up service)
6. Build and verify: `pnpm --filter @shire/db build`

## Verification

1. Run `pnpm --filter @shire/db build` — TypeScript compiles with no errors
2. Run `pnpm build` — Full monorepo build succeeds (desktop app can import the new exports)
3. Spot-check: `pnpm dev` launches the Electron app without crashes (service initializes alongside the database)
